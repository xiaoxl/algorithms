# Graph algorithm


{{< include ../math.qmd >}}


- sd
- 2-SAT
- Bellman-Ford
- F-W
- Negative cycle(?)



## Data strcuture

- adjacency matrix
- adjacency list

Which is better depends on the relation between $|V|$ and $|E|$. $|V|\leq|E|\leq|V|^2$. 

- When $|E|\sim |V|^2$, the graph is *dense*: maybe better with matrix
- When $|E|\sim |V|$, the graph is *sparse*: maybe better with list


## DFS

### get connected components in undirected G?


An algorithm to explore all nods

modify it when we want to do different things at each nodes

explore all nods

``` pseudocode
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true

\begin{algorithm}
\caption{Explore: finding all nodes reachable from a particular node}
\begin{algorithmic}
\Require $G=(V,E)$
\Ensure some postconditions
\Procedure{DFS}{G}
    \State $cc=0$
    \For {$v\in V$}
        \State visited(v)=False
    \EndFor
    \For {$v\in V$}
        \If {not visited u}
            \State cc++
            \State \Call{explotre}{v}
        \EndIf
    \EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
```

``` pseudocode
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true

\begin{algorithm}
\caption{explore}
\begin{algorithmic}
\Procedure{Explore}{z}
    \State ccnum(z)=cc
    \State visited(z)=True
    \For {$(z,w)\in E$}
        \If {not visited (w)}
            \State \Call{Explore}{w}
        \EndIf
    \EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
```

This ccnum is a number to identify the connected component.


<!-- - undirected graphs
- directed graphs
  - DAG = directed acyclic graph
    - topological sorting
  - SCC: to find SCC: with 2 DFS's -->

at each nodes count the number of cc

![](assests/img/20250211112048.png)



Run DFS and Keep track of component #


DFS(G):

input G=(V,E) in adjacency list represenation
output: vertices labelled by connected components

![](assests/img/20250213162336.png)

### pre and post order

increment the clock when first visit the node (pre order)
increment the clock when finish visiting the node (post order)

we mainly use post order


topological ordering: post order from high to low:

nodes from source to sink

- only back link will create link from low to high, so if no low to high link then no cycles


### sorting

- First run DFS to get post order (O(n+m))
- then sort post order
    - this sorting: all values are from 1 to 2n at most. So create a list and directly fill the node in the corresponding index. Then read it from right to left to get the sorting. (O(n))

so the runtime to get topological sorting is O(n+m)


### DAG:

a generaal graph -> metagraph (with scc) is a DAG ->





### Stringly Connected Components
This is the counterpart of cc in directed graph

scc: directed = cc : undirected

![](assests/img/20250213162732.png)

![](assests/img/20250213163017.png)


DFS tree:

1. a back edge means that there is b->a where b is an descendent of a
2. i->a->b->...->i-1 all are reachable from i. so they are in the subtree from i

![](assests/img/20250213170223.png)


### directed graphs


DAG directed acyclic graph

no cycles=no back edges

Run DFS on DAG G
no back edges=all post order numbers go lower->higher

so for all z->w, post(z)>post(w)


Topological sorting: decreasing post #

max post #=2n

O(n+m)


- Source: no incoming = highest post #
- Sink: no outgoing = lowest post #


ist one has to be a source


alternative: find the sink and go backwards

### SCC

strongly connected: if v->w, w->v


::: {#thm-}
## Metagraph
The metagraph of any directed graph is a DAG.
:::

::: {#thm-}
## Source

- Start from a random vertex and run DFS. The scc with the highest post order node is a source scc.
- Start from a random vertex and run DFS. The scc with the lowest post order node MAY NOT BE a source scc (counter example). 
:::
::: {.proof}
1. For S and S', if $v\in S\rightarrow w\in S'$, then max post # in S > max post # in S'.
2. Then topologically sort by max post #


proof of 1:
Run DFS on G. some vertex z in S u S' visited first. 

- if z in S', all w in S' will be visited and finished before we visit any v in S. So any post order # in S' will be smaller than any pre order # in S.
- if z in S, then all nodes in S' should be finished before z. So post number of z is higher than any post number in S'.


:::


How to find a sink?

Reverse the direction and run the above algorithm to find the source.

::: {#thm-}
The source of a G is the sink of reverse G.

:::



Algorithm
1. reverse arrow
2. run dfs and find the source scc
3. remove it 
4. run dfs again and find the source scc and remove
5. 

This will find scc
![](assests/img/20250213205309.png)

this is to give scc
![](assests/img/20250213205008.png)

we can get sccs in topological order


``` pseudocode
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true

\begin{algorithm}
\caption{SCC}
\begin{algorithmic}
\Procedure{SCC}{G}
    \State construct GR
    \State DFS(GR)
    \State Order V by post number
    \State \Call{undirected-cc}{G}
\EndProcedure
\end{algorithmic}
\end{algorithm}
```
The undirected cc algorith we just use the directly variation with identical code
all cc is scc in this case

in the code every node has a ccnum number which gives us the scc componentes.



### BFS
DFS: connectivity
BFS: layers


BFS: 
- input: G, starting node
- output for all v, dist(v)=min {# edges from s to v} and prev(v)
- O(n+m)


Dijkstra's (a version of BFS)
- input: G, s
- output: for all v, dist(v)=length of shortest s to v
- using min-heap datastructure
- O((n+m)\ln n)

min-heap: priority queue: each operation here take log n time. So Dijkstra takes O((n+m) logn) time.







## 2-SAT

satisfiability 

literals: x1-xn, x1b-xnb
CNF: clause: OR of several literals
formula in CNF is AND of m clauses


### SAT

input: n var, m clauses
output: find if there are assignments that the formula is True


### k-SAT
the size of each claues is <= k

SAT is NP-complete
k-SAT is NP-complete for k>=3

but 2-SAT is P

![](assests/img/20250213223641.png)

first simplify the formula to be all 2

create a directe graph

2n vertices

(a or b): abar->b, bbar->a

path of implication

if a->abar, it is not possible

if a and abar is in scc, then the formaula cannot be satisfied.

![](assests/img/20250213224430.png)

- approach 1: 
  - set the sink is true. if the complement is the source and it is automatically false, it is good.
![](assests/img/20250213224920.png)
- approach 2:
  - set the source to be false. 
- 


![](assests/img/20250213225338.png)


2SAT(f):
1. construct graph G
2. Take a sink SCC S
   1. set S=T and Sbar=F
   2. remove S and Sbar
   3. repeat until empty

O(n+m)


Key fact  if fall all xi and xibar are in different SCC, then S is a sink SCC <-> Sbar is a source SCC


::: {.proof}
claim: a->b, then bbar->abar [proof: a->b comes from (abar or b), and this clause also gives bbar->abar]

Then if a,b in SCC, then abar and bbar in SCC

so S is a SCC, then Sbar is a SCC

Take sink SCC S: then no edges s->w

then no wbar->sbar. so Sbar is a source.


:::









## PageRank






## Summary

- DFS: undirected graph connectivity 
- DFS: directed scc
- topological ordering (?)
- 2-SAT
- shortest path
  - Bellman-Ford
  - Floyd-Warshall
- MST
  - kurskla
  - prim


cycle detection

DAG structure" topological ordering

1. DFS











Per Dr. Brito's announcement, you can use this thread to discuss strategies and solutions for the below problems.

[DPV] Chapter 3 (DFS, SCC). Problems 3.1-3.5, 3.7, 3.8, 3.11, 3.15, 3.16, 3.22, 3.24.

[DPV] Chapter 4 (BFS, Shortest paths). Problems 4.1-4.3, 4.8, 4.11, 4.12-4.14, 4.20, 4,21.

[DPV] Chapter 5 (MSTs). Problems 5.1, 5.2, 5.5, 5.6, 5,7, 5.9, 5.20, 5.22, 5.23.

[DPV] Chapter 7 (Flows). Problems 7.18 parts (a) & (b), 7.19, 7.21, 7.22, 7.24(*hard)

Also, here are some problems we will release sample solutions for:

[DPV] Chapter 7 (Flows) - Problems 7.10, 7.17, and 7.19






::: {#exr-}
## 3.1


:::






Suggested reading

Chapter 3 (Graph traversal)

Instructions

For the graded problems, you can use the algorithms from class as black-boxes without further explanation. They are as follows:

Depth-First Search (DFS)
Topological Sort
Strongly Connected Components (SCC)
Breadth-First Search (BFS)
Dijkstra's
Bellman-Ford (BF)
Floyd-Warshall (FW)
Kruskal's
Prim's
Ford-Fulkerson (FF)
Edmonds-Karp (EK)
2-SAT
When using a black-box, make sure you clearly describe which input you are passing into it and how you use the output or take advantage of the data structures created by the algorithm. To receive full credit, your solution must:

Include the description of your algorithm in words (no pseudocode!).

Explain the correctness of your design.

State and analyze the running time of your design (you can cite and use the running time of black-boxes without further explanations).

Black boxes must be used without modification.

Example: I take the input graph G, I first find the vertex with largest degree, call it v*. I take the complement of the graph G, call it G'. Run Dijkstra’s algorithm on G' with s = v* and then I get the array dist[v] of the shortest path lengths from s to every other vertex in the graph G'. I square each of these distances and return this new array.

We don’t want you to go into the details of these algorithms and tinker with it, just use it as a black-box as shown with Dijkstra’s algorithm above.

Practice Problems (do not turn in)

[DPV] Problem 3.3 (Topological ordering example)

[DPV] Problem 3.4 (SCC algorithm example)

[DPV] Problem 3.5 (Reverse of graph)

[DPV] Problem 3.15 (Computopia)



Assigned Reading 

Chapter 4 (Dijkstra's), Chapter 5 (MST)

Practice Problems

[DPV] Problem 4.14 (Shortest path through a given vertex)

[DPV] Problems 5.1, 5.2 (Practice fundamentals of MST designs)

[DPV] Problem 5.9 (multiple statements about MST. We will provide the answer to a few, you are welcome to try them all)















cut proerty

cycle property




undirected:
- dfs for cc


directed
- topological ordering
- scc: 2 dfs: first ordering, then do it again
- 2sat: scc
  
mst:
- kulskra: tree properties: always add smallest wt edge
- prim: cut property: add smallest wt edge across cut

shortest path
- dijstra: positive weights
- bf: starting from a single point with negative wt
- fw: any two pairs with negative wt

![](assests/img/20250227224206.png)

![](assests/img/20250227224216.png)

![](assests/img/20250227224225.png)

![](assests/img/20250227224234.png)